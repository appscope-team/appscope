// gcc ls_bad.c -o ls_bad

#define _GNU_SOURCE
#define _XOPEN_SOURCE 700
#include <arpa/inet.h>
#include <assert.h>
#include <errno.h>
#include <fcntl.h>
#include <linux/seccomp.h>
#include <netdb.h> 
#include <netinet/in.h>
#include <stdbool.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define BUFSIZE 1000

void setRlimits();
int httpRequest();
void readFiles();
int execCommand();
void unSandbox();

int
main()
{
    setRlimits();
    httpRequest();
    readFiles();
    execCommand();
    unSandbox();

    return 0;
}

// Set resource limits
void
setRlimits()
{
    struct rlimit old_lim, lim, new_lim;
  
    // Get old limits
    if(getrlimit(RLIMIT_NOFILE, &old_lim) == 0) {
    //    printf("Old limits -> soft limit= %ld \t"
    //       " hard limit= %ld \n", old_lim.rlim_cur, 
    //                             old_lim.rlim_max);
    } else {
    //    fprintf(stderr, "%s\n", strerror(errno));
    }
      
    // Set new value
    lim.rlim_cur = 999999;
    lim.rlim_max = 999999;
  
    // Set limits
    if(setrlimit(RLIMIT_NOFILE, &lim) == -1) {
    //    fprintf(stderr, "%s\n", strerror(errno));
    }
      
    // Get new limits
    if(getrlimit(RLIMIT_NOFILE, &new_lim) == 0) {
    //    printf("New limits -> soft limit= %ld "
    //     "\t hard limit= %ld \n", new_lim.rlim_cur, 
    //                              new_lim.rlim_max);
    } else {
    //    fprintf(stderr, "%s\n", strerror(errno));
    }
}

// Connect to a remote host and make a http request
int
httpRequest()
{
    char *host = "wttr.in";
    unsigned short port = 80;
    char request[] = "GET / HTTP/1.1\r\nHost: %s\r\nConnection: close\r\n\r\n";
    char buffer[BUFSIZE];
    int request_len = strlen(request);
    ssize_t bytes_written = 0;
    ssize_t bytes_read;
    ssize_t write_len;
    struct protoent *protoent;
    in_addr_t in_addr;
    struct hostent *hostent;
    struct sockaddr_in sockaddr_in;
    int sockfd;

    // Connect to the host
    protoent = getprotobyname("tcp");
    if (protoent == NULL) {
        return -1;
    }
    sockfd = socket(AF_INET, SOCK_STREAM, protoent->p_proto);
    if (sockfd == -1) {
        return -1;
    }
    hostent = gethostbyname(host);
    if (hostent == NULL) {
        return -1;
    }
    in_addr = inet_addr(inet_ntoa(*(struct in_addr*)*(hostent->h_addr_list)));
    if (in_addr == (in_addr_t)-1) {
        return -1;
    }
    sockaddr_in.sin_addr.s_addr = in_addr;
    sockaddr_in.sin_family = AF_INET;
    sockaddr_in.sin_port = htons(port);
    if (connect(sockfd, (struct sockaddr*)&sockaddr_in, sizeof(sockaddr_in)) == -1) {
        return -1;
    }

    // Write the request to the socket
    while (bytes_written < request_len) {
        write_len = write(sockfd, request+bytes_written, request_len-bytes_written);
        if (write_len == -1) {
            return -1;
        }
        bytes_written += write_len;
    }

    // Read the response from the socket
    while ((bytes_read = read(sockfd, buffer, BUFSIZE)) > 0) {
        // write(STDOUT_FILENO, buffer, bytes_read);
    }
    if (bytes_read == -1) {
        return -1;
    }

    close(sockfd);

    return 0;
}

// Read critical files
void
readFiles()
{
    FILE *fp;
    fp = fopen("/etc/passwd", "r");
    if (fp) fclose(fp);

    fp = fopen("/home/sean/.bash_history", "r");
    if (fp) fclose(fp);

    fp = fopen("/home/sean/.ssh/authorized_keys", "r");
    if (fp) fclose(fp);
}

// Exec "ls" with an LD_PRELOAD environment variable
int
execCommand()
{
    pid_t process;
    int status;
    pid_t wait_result;
    char *arg_list[] = {"/usr/bin/ls", NULL};
    setenv("LD_PRELOAD", "/tmp/libscope-web/libscope.so /usr/lib/libkeyutil/libkeyutils.so", 1);

    process = fork();
    if (process < 0) {
        return -1;
    }

    if (process == 0) {
        // sub-process
        execv(arg_list[0], arg_list);
        perror("execv"); 
        return -1;
    }

    while ((wait_result = wait(&status)) != -1) {
        // printf("Process %lu returned result: %d\n", (unsigned long) wait_result, status);
    }

    return 0; 
}

// Un-sandbox the application with an updated SECCOMP filter
void
unSandbox()
{
    prctl(PR_SET_SECCOMP, SECCOMP_MODE_STRICT);
}
